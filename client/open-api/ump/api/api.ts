/* eslint-disable max-len */
/* eslint-disable @typescript-eslint/no-explicit-any */
/* eslint-disable valid-jsdoc */

// tslint:disable
/**
 * FastAPI
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 0.1.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import * as globalImportUrl from 'url'

import globalAxios, { AxiosPromise, AxiosInstance } from 'axios'

import { Configuration } from './configuration'
// Some imports not used depending on template conditions
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base'

/**
 *
 * @export
 * @interface AMessage
 */
export interface AMessage {
    /**
     *
     * @type {string}
     * @memberof AMessage
     */
    id: string;
    /**
     *
     * @type {string}
     * @memberof AMessage
     */
    chat_id: string;
    /**
     *
     * @type {string}
     * @memberof AMessage
     */
    from_id: string;
    /**
     *
     * @type {Array<Reaction>}
     * @memberof AMessage
     */
    reactions?: Array<Reaction>;
    /**
     *
     * @type {string}
     * @memberof AMessage
     */
    text?: string;
    /**
     *
     * @type {string}
     * @memberof AMessage
     */
    audio?: string;
    /**
     *
     * @type {string}
     * @memberof AMessage
     */
    video?: string;
    /**
     *
     * @type {string}
     * @memberof AMessage
     */
    img?: string;
    /**
     *
     * @type {string}
     * @memberof AMessage
     */
    files?: string;
    /**
     *
     * @type {boolean}
     * @memberof AMessage
     */
    is_read?: boolean;
    /**
     *
     * @type {string}
     * @memberof AMessage
     */
    timestamp: string;
    /**
     *
     * @type {Message}
     * @memberof AMessage
     */
    answer?: Message;
}
/**
 *
 * @export
 * @interface BodyLoginForAccessTokenClientTokenPost
 */
export interface BodyLoginForAccessTokenClientTokenPost {
    /**
     *
     * @type {string}
     * @memberof BodyLoginForAccessTokenClientTokenPost
     */
    grant_type?: string;
    /**
     *
     * @type {string}
     * @memberof BodyLoginForAccessTokenClientTokenPost
     */
    username: string;
    /**
     *
     * @type {string}
     * @memberof BodyLoginForAccessTokenClientTokenPost
     */
    password: string;
    /**
     *
     * @type {string}
     * @memberof BodyLoginForAccessTokenClientTokenPost
     */
    scope?: string;
    /**
     *
     * @type {string}
     * @memberof BodyLoginForAccessTokenClientTokenPost
     */
    client_id?: string;
    /**
     *
     * @type {string}
     * @memberof BodyLoginForAccessTokenClientTokenPost
     */
    client_secret?: string;
}
/**
 *
 * @export
 * @interface BodyUpdateMeetingMeetingUpdatePatch
 */
export interface BodyUpdateMeetingMeetingUpdatePatch {
    /**
     *
     * @type {Array<string>}
     * @memberof BodyUpdateMeetingMeetingUpdatePatch
     */
    add_users?: Array<string>;
    /**
     *
     * @type {Array<string>}
     * @memberof BodyUpdateMeetingMeetingUpdatePatch
     */
    remove_users?: Array<string>;
}
/**
 * Модель пользователя чата.  Attributes:     companion (Optional[UserWithoutPassword]): Собеседник.     last_message (Optional[Msg]): Последнее сообщение.     id (str): Идентификатор чата.     unread_messages (Optional[int]): Количество непрочитанных сообщений.     name (Optional[str]): Имя чата.     avatar (Optional[str]): Аватар чата.
 * @export
 * @interface ChatUser
 */
export interface ChatUser {
    /**
     *
     * @type {UserWithoutPassword}
     * @memberof ChatUser
     */
    companion: UserWithoutPassword;
    /**
     *
     * @type {Message}
     * @memberof ChatUser
     */
    last_message?: Message | null;
    /**
     *
     * @type {string}
     * @memberof ChatUser
     */
    id: string;
    /**
     *
     * @type {number}
     * @memberof ChatUser
     */
    unread_messages?: number;
    /**
     *
     * @type {string}
     * @memberof ChatUser
     */
    name?: string;
    /**
     *
     * @type {string}
     * @memberof ChatUser
     */
    avatar?: string;
}
/**
 * Модель беседы.  Attributes:     name (Optional[str]): Название беседы.     avatar (Optional[str]): Аватар беседы.
 * @export
 * @interface Conversation
 */
export interface Conversation {
    /**
     *
     * @type {string}
     * @memberof Conversation
     */
    id: string;
    /**
     *
     * @type {Array<string>}
     * @memberof Conversation
     */
    participants: Array<string>;
    /**
     *
     * @type {string}
     * @memberof Conversation
     */
    timestamp: string;
    /**
     *
     * @type {string}
     * @memberof Conversation
     */
    last_message?: string | null;
    /**
     *
     * @type {string}
     * @memberof Conversation
     */
    last_message_type?: string | null;
    /**
     *
     * @type {UserWithoutPassword}
     * @memberof Conversation
     */
    user?: UserWithoutPassword | null;
    /**
     *
     * @type {Message}
     * @memberof Conversation
     */
    message?: Message | null;
    /**
     *
     * @type {string}
     * @memberof Conversation
     */
    name?: string | null;
    /**
     *
     * @type {string}
     * @memberof Conversation
     */
    avatar?: string | null;
}
/**
 * Запрос на создание беседы.  Attributes:     participants (List[str]): Список участников беседы.     name (str): Название беседы.     avatar (Optional[str]): Аватар беседы.
 * @export
 * @interface CreateConversationRequest
 */
export interface CreateConversationRequest {
    /**
     *
     * @type {Array<string>}
     * @memberof CreateConversationRequest
     */
    participants: Array<string>;
    /**
     *
     * @type {string}
     * @memberof CreateConversationRequest
     */
    name: string;
    /**
     *
     * @type {string}
     * @memberof CreateConversationRequest
     */
    avatar?: string | null;
}
/**
 * Ответ на запрос создания беседы.  Attributes:     chat_id (str): Идентификатор созданной беседы.
 * @export
 * @interface CreateConversationResponse
 */
export interface CreateConversationResponse {
    /**
     *
     * @type {string}
     * @memberof CreateConversationResponse
     */
    chat_id: string;
}
/**
 * Модель стандартного ответа на регистрацию.  Attributes:     status (Status): Статус ответа.     message (str): Сообщение ответа.     id (Optional[uuid.UUID]): Идентификатор регистрации (если доступен).
 * @export
 * @interface DefaultResponseRegister
 */
export interface DefaultResponseRegister {
    /**
     *
     * @type {Status}
     * @memberof DefaultResponseRegister
     */
    status: Status;
    /**
     *
     * @type {string}
     * @memberof DefaultResponseRegister
     */
    message: string;
    /**
     *
     * @type {string}
     * @memberof DefaultResponseRegister
     */
    id?: string | null;
}
/**
 * Перечисление форматов встречи.  Attributes:     online (str): Онлайн формат встречи.     offline (str): Офлайн формат встречи.
 * @export
 * @enum {string}
 */
export enum Format {
    Online = 'online',
    Offline = 'offline'
}

/**
 * Ответ на запрос получения чатов.  Attributes:     chats (List[ChatUser]): Список чатов.     conversation (Optional[Conversation]): Текущая беседа.
 * @export
 * @interface GetChatsResponse
 */
export interface GetChatsResponse {
    /**
     *
     * @type {Array<ChatUser>}
     * @memberof GetChatsResponse
     */
    chats: Array<ChatUser>;
    /**
     *
     * @type {Conversation}
     * @memberof GetChatsResponse
     */
    conversation?: Conversation | null;
}
/**
 * Ответ на запрос получения сообщения.  Attributes:     id (str): Идентификатор сообщения.     chat_id (str): Идентификатор чата.     from_id (str): Идентификатор отправителя.     reactions (Optional[List[Reaction]]): Список реакций.     text (Optional[str]): Текст сообщения.     audio (Optional[str]): URL аудио.     video (Optional[str]): URL видео.     img (Optional[str]): URL изображения.     files (Optional[str]): URL файлов.     timestamp (datetime.datetime): Время отправки сообщения.     is_read (Optional[bool]): Статус прочтения сообщения.
 * @export
 * @interface GetMessageResponse
 */
export interface GetMessageResponse {
    /**
     *
     * @type {string}
     * @memberof GetMessageResponse
     */
    id: string;
    /**
     *
     * @type {string}
     * @memberof GetMessageResponse
     */
    chat_id: string;
    /**
     *
     * @type {string}
     * @memberof GetMessageResponse
     */
    from_id: string;
    /**
     *
     * @type {Array<Reaction>}
     * @memberof GetMessageResponse
     */
    reactions?: Array<Reaction> | null;
    /**
     *
     * @type {string}
     * @memberof GetMessageResponse
     */
    text?: string | null;
    /**
     *
     * @type {string}
     * @memberof GetMessageResponse
     */
    audio?: string | null;
    /**
     *
     * @type {string}
     * @memberof GetMessageResponse
     */
    video?: string | null;
    /**
     *
     * @type {string}
     * @memberof GetMessageResponse
     */
    img?: string | null;
    /**
     *
     * @type {string}
     * @memberof GetMessageResponse
     */
    files?: string | null;
    /**
     *
     * @type {string}
     * @memberof GetMessageResponse
     */
    timestamp: string;
    /**
     *
     * @type {AMessage}
     * @memberof GetMessageResponse
     */
    answer?: AMessage;
    /**
     *
     * @type {boolean}
     * @memberof GetMessageResponse
     */
    is_read?: boolean;
}
/**
 * Ответ на запрос получения списка сообщений.  Attributes:     messages (List[Optional[GetMessageResponse]]): Список сообщений.
 * @export
 * @interface GetMessageResponseList
 */
export interface GetMessageResponseList {
    /**
     *
     * @type {Array<GetMessageResponse>}
     * @memberof GetMessageResponseList
     */
    messages?: Array<GetMessageResponse> | null;
}
/**
 * Модель ответа на запрос получения пользователей.  Attributes:     data (Optional[List[UserFindModel]]): Список найденных пользователей.
 * @export
 * @interface GetUsersResponse
 */
export interface GetUsersResponse {
    /**
     *
     * @type {Array<UserFindModel>}
     * @memberof GetUsersResponse
     */
    data: Array<UserFindModel>;
}
/**
 *
 * @export
 * @interface HTTPValidationError
 */
export interface HTTPValidationError {
    /**
     *
     * @type {Array<ValidationError>}
     * @memberof HTTPValidationError
     */
    detail?: Array<ValidationError>;
}
/**
 * Модель встречи.  Attributes:     participants (List[UserMeeting]): Список участников встречи.     id (str): Идентификатор встречи.     is_active (bool): Статус активности встречи.     creator_id (str): Идентификатор создателя встречи.     timestamp (datetime.datetime): Временная метка создания встречи.
 * @export
 * @interface Meeting
 */
export interface Meeting {
    /**
     *
     * @type {string}
     * @memberof Meeting
     */
    start_time: string;
    /**
     *
     * @type {string}
     * @memberof Meeting
     */
    end_time: string;
    /**
     *
     * @type {Array<UserMeeting>}
     * @memberof Meeting
     */
    participants: Array<UserMeeting>;
    /**
     *
     * @type {string}
     * @memberof Meeting
     */
    title?: string;
    /**
     *
     * @type {string}
     * @memberof Meeting
     */
    description?: string | null;
    /**
     *
     * @type {string}
     * @memberof Meeting
     */
    link?: string | null;
    /**
     *
     * @type {string}
     * @memberof Meeting
     */
    room?: string | null;
    /**
     *
     * @type {Format}
     * @memberof Meeting
     */
    format: Format;
    /**
     *
     * @type {boolean}
     * @memberof Meeting
     */
    send_notification?: boolean;
    /**
     *
     * @type {string}
     * @memberof Meeting
     */
    id: string;
    /**
     *
     * @type {boolean}
     * @memberof Meeting
     */
    is_active: boolean;
    /**
     *
     * @type {string}
     * @memberof Meeting
     */
    creator_id: string;
    /**
     *
     * @type {string}
     * @memberof Meeting
     */
    timestamp: string;
}
/**
 * Модель сообщения.  Attributes:     id (str): Идентификатор сообщения.     chat_id (str): Идентификатор чата.     from_id (str): Идентификатор отправителя.     reactions (Optional[List[Reaction]]): Список реакций на сообщение.     text (Optional[str]): Текст сообщения.     audio (Optional[str]): Аудио сообщение.     video (Optional[str]): Видео сообщение.     img (Optional[str]): Изображение в сообщении.     files (Optional[str]): Файлы в сообщении.     is_read (Optional[bool]): Статус прочтения сообщения.     timestamp (datetime.datetime): Временная метка сообщения.
 * @export
 * @interface Message
 */
export interface Message {
    /**
     *
     * @type {string}
     * @memberof Message
     */
    id: string;
    /**
     *
     * @type {string}
     * @memberof Message
     */
    chat_id: string;
    /**
     *
     * @type {string}
     * @memberof Message
     */
    from_id: string;
    /**
     *
     * @type {Array<Reaction>}
     * @memberof Message
     */
    reactions?: Array<Reaction>;
    /**
     *
     * @type {string}
     * @memberof Message
     */
    text?: string;
    /**
     *
     * @type {string}
     * @memberof Message
     */
    audio?: string;
    /**
     *
     * @type {string}
     * @memberof Message
     */
    video?: string;
    /**
     *
     * @type {string}
     * @memberof Message
     */
    img?: string;
    /**
     *
     * @type {string}
     * @memberof Message
     */
    files?: string;
    /**
     *
     * @type {boolean}
     * @memberof Message
     */
    is_read?: boolean;
    /**
     *
     * @type {string}
     * @memberof Message
     */
    timestamp: string;
}
/**
 * Модель реакции на сообщение.  Attributes:     reaction (str): Тип реакции.     from_user (UserWithoutPassword): Пользователь, оставивший реакцию.
 * @export
 * @interface Reaction
 */
export interface Reaction {
    /**
     *
     * @type {string}
     * @memberof Reaction
     */
    reaction: string;
    /**
     *
     * @type {UserWithoutPassword}
     * @memberof Reaction
     */
    from_user: UserWithoutPassword;
}
/**
 * Модель ответа на запрос создания встречи.  Attributes:     id (str): Идентификатор созданной встречи.
 * @export
 * @interface ResponseCreateMeeting
 */
export interface ResponseCreateMeeting {
    /**
     *
     * @type {string}
     * @memberof ResponseCreateMeeting
     */
    id: string;
}
/**
 * Модель ответа на запрос обновления данных пользователя.  Attributes:     count (int): Количество обновленных записей.
 * @export
 * @interface ResponseUpdateUserData
 */
export interface ResponseUpdateUserData {
    /**
     *
     * @type {number}
     * @memberof ResponseUpdateUserData
     */
    count: number;
}
/**
 * Перечисление статусов ответа.  Attributes:     error (str): Ошибка.     success (str): Успех.
 * @export
 * @enum {string}
 */
export enum Status {
    Error = 'error',
    Success = 'success'
}

/**
 * Модель токена доступа.  Attributes:     access_token (str): Токен доступа.     token_type (str): Тип токена.
 * @export
 * @interface Token
 */
export interface Token {
    /**
     *
     * @type {string}
     * @memberof Token
     */
    access_token: string;
    /**
     *
     * @type {string}
     * @memberof Token
     */
    token_type: string;
}
/**
 * Перечисление типов идентификаторов пользователя.  Attributes:     phone (str): Идентификатор типа телефон.     email (str): Идентификатор типа email.     login (str): Идентификатор типа логин.
 * @export
 * @enum {string}
 */
export enum TypeID {
    Phone = 'phone',
    Email = 'email',
    Login = 'login'
}

/**
 * Модель найденного пользователя.  Attributes:     id (str): Уникальный идентификатор пользователя.     firstname (str): Имя пользователя.     middlename (Optional[str]): Отчество пользователя.     lastname (str): Фамилия пользователя.     position (Optional[str]): Должность пользователя.     email (EmailStr): Электронная почта пользователя.     img (Optional[str]): URL изображения пользователя.     company (Optional[str]): Компания пользователя (в будущем).     login (Optional[str]): Логин пользователя.     status (Optional[str]): Статус пользователя.
 * @export
 * @interface UserFindModel
 */
export interface UserFindModel {
    /**
     *
     * @type {string}
     * @memberof UserFindModel
     */
    id: string;
    /**
     *
     * @type {string}
     * @memberof UserFindModel
     */
    firstname: string;
    /**
     *
     * @type {string}
     * @memberof UserFindModel
     */
    middlename?: string | null;
    /**
     *
     * @type {string}
     * @memberof UserFindModel
     */
    lastname: string;
    /**
     *
     * @type {string}
     * @memberof UserFindModel
     */
    position?: string | null;
    /**
     *
     * @type {string}
     * @memberof UserFindModel
     */
    email: string;
    /**
     *
     * @type {string}
     * @memberof UserFindModel
     */
    img?: string | null;
    /**
     *
     * @type {string}
     * @memberof UserFindModel
     */
    company?: string | null;
    /**
     *
     * @type {string}
     * @memberof UserFindModel
     */
    login?: string | null;
    /**
     *
     * @type {string}
     * @memberof UserFindModel
     */
    status?: string | null;
}
/**
 * Модель пользователя для встречи.  Attributes:     id (str): Идентификатор пользователя.     email (EmailStr): Электронная почта пользователя.     position (Optional[str]): Должность пользователя.     firstname (str): Имя пользователя.     middlename (Optional[str]): Отчество пользователя.     lastname (str): Фамилия пользователя.     login (Optional[str]): Логин пользователя.     phone (str): Телефон пользователя.     avatar (Optional[str]): Аватар пользователя.     company_id (Optional[str]): Идентификатор компании пользователя.
 * @export
 * @interface UserMeeting
 */
export interface UserMeeting {
    /**
     *
     * @type {string}
     * @memberof UserMeeting
     */
    id: string;
    /**
     *
     * @type {string}
     * @memberof UserMeeting
     */
    email: string;
    /**
     *
     * @type {string}
     * @memberof UserMeeting
     */
    position?: string | null;
    /**
     *
     * @type {string}
     * @memberof UserMeeting
     */
    firstname: string;
    /**
     *
     * @type {string}
     * @memberof UserMeeting
     */
    middlename?: string | null;
    /**
     *
     * @type {string}
     * @memberof UserMeeting
     */
    lastname: string;
    /**
     *
     * @type {string}
     * @memberof UserMeeting
     */
    login?: string | null;
    /**
     *
     * @type {string}
     * @memberof UserMeeting
     */
    phone: string;
    /**
     *
     * @type {string}
     * @memberof UserMeeting
     */
    avatar?: string | null;
    /**
     *
     * @type {string}
     * @memberof UserMeeting
     */
    company_id?: string | null;
}
/**
 * Модель пользователя без пароля.  Attributes:     id (str): Идентификатор пользователя.     email (EmailStr): Электронная почта пользователя.     position (Optional[str]): Должность пользователя.     firstname (str): Имя пользователя.     middlename (Optional[str]): Отчество пользователя.     lastname (str): Фамилия пользователя.     login (Optional[str]): Логин пользователя.     phone (str): Телефон пользователя.     avatar (Optional[str]): Аватар пользователя.     invitation_code (str): Код приглашения пользователя.     company_id (Optional[str]): Идентификатор компании пользователя.     status (Optional[str]): Статус пользователя.
 * @export
 * @interface UserWithoutPassword
 */
export interface UserWithoutPassword {
    /**
     *
     * @type {string}
     * @memberof UserWithoutPassword
     */
    id: string;
    /**
     *
     * @type {string}
     * @memberof UserWithoutPassword
     */
    email: string;
    /**
     *
     * @type {string}
     * @memberof UserWithoutPassword
     */
    position?: string | null;
    /**
     *
     * @type {string}
     * @memberof UserWithoutPassword
     */
    firstname: string;
    /**
     *
     * @type {string}
     * @memberof UserWithoutPassword
     */
    middlename?: string | null;
    /**
     *
     * @type {string}
     * @memberof UserWithoutPassword
     */
    lastname: string;
    /**
     *
     * @type {string}
     * @memberof UserWithoutPassword
     */
    login?: string | null;
    /**
     *
     * @type {string}
     * @memberof UserWithoutPassword
     */
    phone: string;
    /**
     *
     * @type {string}
     * @memberof UserWithoutPassword
     */
    avatar?: string | null;
    /**
     *
     * @type {string}
     * @memberof UserWithoutPassword
     */
    invitation_code: string;
    /**
     *
     * @type {string}
     * @memberof UserWithoutPassword
     */
    company_id?: string | null;
    /**
     *
     * @type {string}
     * @memberof UserWithoutPassword
     */
    status?: string | null;
}
/**
 *
 * @export
 * @interface ValidationError
 */
export interface ValidationError {
    /**
     *
     * @type {Array<string | number>}
     * @memberof ValidationError
     */
    loc: Array<string | number>;
    /**
     *
     * @type {string}
     * @memberof ValidationError
     */
    msg: string;
    /**
     *
     * @type {string}
     * @memberof ValidationError
     */
    type: string;
}

/**
 * AuthApi - axios parameter creator
 * @export
 */
export const AuthApiAxiosParamCreator = function(configuration?: Configuration) {
  return {
    /**
         * Получение текущего аутентифицированного пользователя.  Args:     user (User): Объект аутентифицированного пользователя.  Returns:     UserWithoutPassword: Объект пользователя без пароля.
         * @summary Get Current User
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
    getCurrentUserClientCurrentUserGet(options: any = {}): RequestArgs {
      const localVarPath = '/client/current_user'
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication OAuth2PasswordBearer required
      // oauth required
      if (configuration && configuration.accessToken) {
        const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
          ? configuration.accessToken('OAuth2PasswordBearer', [])
          : configuration.accessToken
        localVarHeaderParameter['Authorization'] = 'Bearer ' + localVarAccessTokenValue
      }

      localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null
      const headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions
      }
    },
    /**
         * Логин и получение токена доступа.  Args:     form_data (OAuth2PasswordRequestForm): Данные формы для логина.  Returns:     Token: Сгенерированный токен доступа.  Raises:     HTTPException: Если аутентификация не удалась.
         * @summary Login For Access Token
         * @param {string} username
         * @param {string} password
         * @param {string} [grantType]
         * @param {string} [scope]
         * @param {string} [clientId]
         * @param {string} [clientSecret]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
    loginForAccessTokenClientTokenPost(username: string, password: string, grantType?: string, scope?: string, clientId?: string, clientSecret?: string, options: any = {}): RequestArgs {
      // verify required parameter 'username' is not null or undefined
      if (username === null || username === undefined) {
        throw new RequiredError('username', 'Required parameter username was null or undefined when calling loginForAccessTokenClientTokenPost.')
      }
      // verify required parameter 'password' is not null or undefined
      if (password === null || password === undefined) {
        throw new RequiredError('password', 'Required parameter password was null or undefined when calling loginForAccessTokenClientTokenPost.')
      }
      const localVarPath = '/client/token'
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any
      const localVarFormParams = new URLSearchParams()

      if (grantType !== undefined) {
        localVarFormParams.set('grant_type', grantType as any)
      }

      if (username !== undefined) {
        localVarFormParams.set('username', username as any)
      }

      if (password !== undefined) {
        localVarFormParams.set('password', password as any)
      }

      if (scope !== undefined) {
        localVarFormParams.set('scope', scope as any)
      }

      if (clientId !== undefined) {
        localVarFormParams.set('client_id', clientId as any)
      }

      if (clientSecret !== undefined) {
        localVarFormParams.set('client_secret', clientSecret as any)
      }

      localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded'

      localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null
      const headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      localVarRequestOptions.data = localVarFormParams.toString()

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions
      }
    },
    /**
         * Обновление токена доступа для текущего пользователя.  Args:     user (User): Объект аутентифицированного пользователя.  Returns:     Token: Новый токен доступа.
         * @summary Refresh Token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
    refreshTokenClientRefreshTokenPost(options: any = {}): RequestArgs {
      const localVarPath = '/client/refresh_token'
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication OAuth2PasswordBearer required
      // oauth required
      if (configuration && configuration.accessToken) {
        const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
          ? configuration.accessToken('OAuth2PasswordBearer', [])
          : configuration.accessToken
        localVarHeaderParameter['Authorization'] = 'Bearer ' + localVarAccessTokenValue
      }

      localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null
      const headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions
      }
    },
    /**
         * Отправка письма для восстановления пароля.  Args:     email (str): Электронная почта пользователя.  Returns:     None
         * @summary Send Restore Pwd
         * @param {string} email
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
    sendRestorePwdClientForgotPwdPost(email: string, options: any = {}): RequestArgs {
      // verify required parameter 'email' is not null or undefined
      if (email === null || email === undefined) {
        throw new RequiredError('email', 'Required parameter email was null or undefined when calling sendRestorePwdClientForgotPwdPost.')
      }
      const localVarPath = '/client/forgot_pwd'
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (email !== undefined) {
        localVarQueryParameter['email'] = email
      }

      localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null
      const headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions
      }
    },
    /**
         * Установка нового пароля с использованием кода восстановления.  Args:     restore_code (str): Код восстановления.     new_pwd (str): Новый пароль.  Returns:     None
         * @summary Set New Pwd
         * @param {string} restoreCode
         * @param {string} newPwd
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
    setNewPwdClientSetNewPwdPost(restoreCode: string, newPwd: string, options: any = {}): RequestArgs {
      // verify required parameter 'restoreCode' is not null or undefined
      if (restoreCode === null || restoreCode === undefined) {
        throw new RequiredError('restoreCode', 'Required parameter restoreCode was null or undefined when calling setNewPwdClientSetNewPwdPost.')
      }
      // verify required parameter 'newPwd' is not null or undefined
      if (newPwd === null || newPwd === undefined) {
        throw new RequiredError('newPwd', 'Required parameter newPwd was null or undefined when calling setNewPwdClientSetNewPwdPost.')
      }
      const localVarPath = '/client/set_new_pwd'
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (restoreCode !== undefined) {
        localVarQueryParameter['restore_code'] = restoreCode
      }

      if (newPwd !== undefined) {
        localVarQueryParameter['new_pwd'] = newPwd
      }

      localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null
      const headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions
      }
    }
  }
}

/**
 * AuthApi - functional programming interface
 * @export
 */
export const AuthApiFp = function(configuration?: Configuration) {
  return {
    /**
         * Получение текущего аутентифицированного пользователя.  Args:     user (User): Объект аутентифицированного пользователя.  Returns:     UserWithoutPassword: Объект пользователя без пароля.
         * @summary Get Current User
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
    getCurrentUserClientCurrentUserGet(options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserWithoutPassword> {
      const localVarAxiosArgs = AuthApiAxiosParamCreator(configuration).getCurrentUserClientCurrentUserGet(options)
      return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
        const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
         * Логин и получение токена доступа.  Args:     form_data (OAuth2PasswordRequestForm): Данные формы для логина.  Returns:     Token: Сгенерированный токен доступа.  Raises:     HTTPException: Если аутентификация не удалась.
         * @summary Login For Access Token
         * @param {string} username
         * @param {string} password
         * @param {string} [grantType]
         * @param {string} [scope]
         * @param {string} [clientId]
         * @param {string} [clientSecret]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
    loginForAccessTokenClientTokenPost(username: string, password: string, grantType?: string, scope?: string, clientId?: string, clientSecret?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Token> {
      const localVarAxiosArgs = AuthApiAxiosParamCreator(configuration).loginForAccessTokenClientTokenPost(username, password, grantType, scope, clientId, clientSecret, options)
      return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
        const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
         * Обновление токена доступа для текущего пользователя.  Args:     user (User): Объект аутентифицированного пользователя.  Returns:     Token: Новый токен доступа.
         * @summary Refresh Token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
    refreshTokenClientRefreshTokenPost(options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Token> {
      const localVarAxiosArgs = AuthApiAxiosParamCreator(configuration).refreshTokenClientRefreshTokenPost(options)
      return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
        const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
         * Отправка письма для восстановления пароля.  Args:     email (str): Электронная почта пользователя.  Returns:     None
         * @summary Send Restore Pwd
         * @param {string} email
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
    sendRestorePwdClientForgotPwdPost(email: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object> {
      const localVarAxiosArgs = AuthApiAxiosParamCreator(configuration).sendRestorePwdClientForgotPwdPost(email, options)
      return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
        const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
         * Установка нового пароля с использованием кода восстановления.  Args:     restore_code (str): Код восстановления.     new_pwd (str): Новый пароль.  Returns:     None
         * @summary Set New Pwd
         * @param {string} restoreCode
         * @param {string} newPwd
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
    setNewPwdClientSetNewPwdPost(restoreCode: string, newPwd: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object> {
      const localVarAxiosArgs = AuthApiAxiosParamCreator(configuration).setNewPwdClientSetNewPwdPost(restoreCode, newPwd, options)
      return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
        const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url }
        return axios.request(axiosRequestArgs)
      }
    }
  }
}

/**
 * AuthApi - factory interface
 * @export
 */
export const AuthApiFactory = function(configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
  return {
    /**
         * Получение текущего аутентифицированного пользователя.  Args:     user (User): Объект аутентифицированного пользователя.  Returns:     UserWithoutPassword: Объект пользователя без пароля.
         * @summary Get Current User
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
    getCurrentUserClientCurrentUserGet(options?: any): AxiosPromise<UserWithoutPassword> {
      return AuthApiFp(configuration).getCurrentUserClientCurrentUserGet(options)(axios, basePath)
    },
    /**
         * Логин и получение токена доступа.  Args:     form_data (OAuth2PasswordRequestForm): Данные формы для логина.  Returns:     Token: Сгенерированный токен доступа.  Raises:     HTTPException: Если аутентификация не удалась.
         * @summary Login For Access Token
         * @param {string} username
         * @param {string} password
         * @param {string} [grantType]
         * @param {string} [scope]
         * @param {string} [clientId]
         * @param {string} [clientSecret]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
    loginForAccessTokenClientTokenPost(username: string, password: string, grantType?: string, scope?: string, clientId?: string, clientSecret?: string, options?: any): AxiosPromise<Token> {
      return AuthApiFp(configuration).loginForAccessTokenClientTokenPost(username, password, grantType, scope, clientId, clientSecret, options)(axios, basePath)
    },
    /**
         * Обновление токена доступа для текущего пользователя.  Args:     user (User): Объект аутентифицированного пользователя.  Returns:     Token: Новый токен доступа.
         * @summary Refresh Token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
    refreshTokenClientRefreshTokenPost(options?: any): AxiosPromise<Token> {
      return AuthApiFp(configuration).refreshTokenClientRefreshTokenPost(options)(axios, basePath)
    },
    /**
         * Отправка письма для восстановления пароля.  Args:     email (str): Электронная почта пользователя.  Returns:     None
         * @summary Send Restore Pwd
         * @param {string} email
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
    sendRestorePwdClientForgotPwdPost(email: string, options?: any): AxiosPromise<object> {
      return AuthApiFp(configuration).sendRestorePwdClientForgotPwdPost(email, options)(axios, basePath)
    },
    /**
         * Установка нового пароля с использованием кода восстановления.  Args:     restore_code (str): Код восстановления.     new_pwd (str): Новый пароль.  Returns:     None
         * @summary Set New Pwd
         * @param {string} restoreCode
         * @param {string} newPwd
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
    setNewPwdClientSetNewPwdPost(restoreCode: string, newPwd: string, options?: any): AxiosPromise<object> {
      return AuthApiFp(configuration).setNewPwdClientSetNewPwdPost(restoreCode, newPwd, options)(axios, basePath)
    }
  }
}

/**
 * AuthApi - object-oriented interface
 * @export
 * @class AuthApi
 * @extends {BaseAPI}
 */
export class AuthApi extends BaseAPI {
  /**
     * Получение текущего аутентифицированного пользователя.  Args:     user (User): Объект аутентифицированного пользователя.  Returns:     UserWithoutPassword: Объект пользователя без пароля.
     * @summary Get Current User
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
  public getCurrentUserClientCurrentUserGet(options?: any) {
    return AuthApiFp(this.configuration).getCurrentUserClientCurrentUserGet(options)(this.axios, this.basePath)
  }

  /**
     * Логин и получение токена доступа.  Args:     form_data (OAuth2PasswordRequestForm): Данные формы для логина.  Returns:     Token: Сгенерированный токен доступа.  Raises:     HTTPException: Если аутентификация не удалась.
     * @summary Login For Access Token
     * @param {string} username
     * @param {string} password
     * @param {string} [grantType]
     * @param {string} [scope]
     * @param {string} [clientId]
     * @param {string} [clientSecret]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
  public loginForAccessTokenClientTokenPost(username: string, password: string, grantType?: string, scope?: string, clientId?: string, clientSecret?: string, options?: any) {
    return AuthApiFp(this.configuration).loginForAccessTokenClientTokenPost(username, password, grantType, scope, clientId, clientSecret, options)(this.axios, this.basePath)
  }

  /**
     * Обновление токена доступа для текущего пользователя.  Args:     user (User): Объект аутентифицированного пользователя.  Returns:     Token: Новый токен доступа.
     * @summary Refresh Token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
  public refreshTokenClientRefreshTokenPost(options?: any) {
    return AuthApiFp(this.configuration).refreshTokenClientRefreshTokenPost(options)(this.axios, this.basePath)
  }

  /**
     * Отправка письма для восстановления пароля.  Args:     email (str): Электронная почта пользователя.  Returns:     None
     * @summary Send Restore Pwd
     * @param {string} email
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
  public sendRestorePwdClientForgotPwdPost(email: string, options?: any) {
    return AuthApiFp(this.configuration).sendRestorePwdClientForgotPwdPost(email, options)(this.axios, this.basePath)
  }

  /**
     * Установка нового пароля с использованием кода восстановления.  Args:     restore_code (str): Код восстановления.     new_pwd (str): Новый пароль.  Returns:     None
     * @summary Set New Pwd
     * @param {string} restoreCode
     * @param {string} newPwd
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
  public setNewPwdClientSetNewPwdPost(restoreCode: string, newPwd: string, options?: any) {
    return AuthApiFp(this.configuration).setNewPwdClientSetNewPwdPost(restoreCode, newPwd, options)(this.axios, this.basePath)
  }
}

/**
 * DefaultApi - axios parameter creator
 * @export
 */
export const DefaultApiAxiosParamCreator = function(configuration?: Configuration) {
  return {
    /**
         *
         * @summary Home
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
    homeGet(options: any = {}): RequestArgs {
      const localVarPath = '/'
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null
      const headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions
      }
    }
  }
}

/**
 * DefaultApi - functional programming interface
 * @export
 */
export const DefaultApiFp = function(configuration?: Configuration) {
  return {
    /**
         *
         * @summary Home
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
    homeGet(options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object> {
      const localVarAxiosArgs = DefaultApiAxiosParamCreator(configuration).homeGet(options)
      return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
        const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url }
        return axios.request(axiosRequestArgs)
      }
    }
  }
}

/**
 * DefaultApi - factory interface
 * @export
 */
export const DefaultApiFactory = function(configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
  return {
    /**
         *
         * @summary Home
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
    homeGet(options?: any): AxiosPromise<object> {
      return DefaultApiFp(configuration).homeGet(options)(axios, basePath)
    }
  }
}

/**
 * DefaultApi - object-oriented interface
 * @export
 * @class DefaultApi
 * @extends {BaseAPI}
 */
export class DefaultApi extends BaseAPI {
  /**
     *
     * @summary Home
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
  public homeGet(options?: any) {
    return DefaultApiFp(this.configuration).homeGet(options)(this.axios, this.basePath)
  }
}

/**
 * MeetingApi - axios parameter creator
 * @export
 */
export const MeetingApiAxiosParamCreator = function(configuration?: Configuration) {
  return {
    /**
         * Отмена встречи.  Args:     params (RequestCancelMeeting): Параметры для отмены встречи.     user (User): Текущий аутентифицированный пользователь.  Raises:     HTTPException: Если встреча не найдена или доступ запрещен.
         * @summary Cancel Meeting
         * @param {string} id
         * @param {boolean} [sendNotification]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
    cancelMeetingMeetingCancelMeetingPatch(id: string, sendNotification?: boolean, options: any = {}): RequestArgs {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError('id', 'Required parameter id was null or undefined when calling cancelMeetingMeetingCancelMeetingPatch.')
      }
      const localVarPath = '/meeting/cancel_meeting'
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication OAuth2PasswordBearer required
      // oauth required
      if (configuration && configuration.accessToken) {
        const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
          ? configuration.accessToken('OAuth2PasswordBearer', [])
          : configuration.accessToken
        localVarHeaderParameter['Authorization'] = 'Bearer ' + localVarAccessTokenValue
      }

      if (id !== undefined) {
        localVarQueryParameter['id'] = id
      }

      if (sendNotification !== undefined) {
        localVarQueryParameter['send_notification'] = sendNotification
      }

      localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null
      const headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions
      }
    },
    /**
         * Создание новой встречи.  Args:     params (RequestCreateMeeting): Параметры для создания встречи.     user (User): Текущий аутентифицированный пользователь.  Returns:     ResponseCreateMeeting: Ответ с идентификатором созданной встречи.
         * @summary Create Meeting
         * @param {string} startTime
         * @param {string} endTime
         * @param {Format} format
         * @param {string} [participants]
         * @param {string} [title]
         * @param {string} [description]
         * @param {string} [link]
         * @param {string} [room]
         * @param {boolean} [sendNotification]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
    createMeetingMeetingCreateMeetingPost(startTime: string, endTime: string, format: Format, participants?: string, title?: string, description?: string, link?: string, room?: string, sendNotification?: boolean, options: any = {}): RequestArgs {
      // verify required parameter 'startTime' is not null or undefined
      if (startTime === null || startTime === undefined) {
        throw new RequiredError('startTime', 'Required parameter startTime was null or undefined when calling createMeetingMeetingCreateMeetingPost.')
      }
      // verify required parameter 'endTime' is not null or undefined
      if (endTime === null || endTime === undefined) {
        throw new RequiredError('endTime', 'Required parameter endTime was null or undefined when calling createMeetingMeetingCreateMeetingPost.')
      }
      // verify required parameter 'format' is not null or undefined
      if (format === null || format === undefined) {
        throw new RequiredError('format', 'Required parameter format was null or undefined when calling createMeetingMeetingCreateMeetingPost.')
      }
      const localVarPath = '/meeting/create_meeting'
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication OAuth2PasswordBearer required
      // oauth required
      if (configuration && configuration.accessToken) {
        const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
          ? configuration.accessToken('OAuth2PasswordBearer', [])
          : configuration.accessToken
        localVarHeaderParameter['Authorization'] = 'Bearer ' + localVarAccessTokenValue
      }

      if (startTime !== undefined) {
        localVarQueryParameter['start_time'] = (startTime as any instanceof Date)
          ? (startTime as any).toISOString()
          : startTime
      }

      if (endTime !== undefined) {
        localVarQueryParameter['end_time'] = (endTime as any instanceof Date)
          ? (endTime as any).toISOString()
          : endTime
      }

      if (participants !== undefined) {
        localVarQueryParameter['participants'] = participants
      }

      if (title !== undefined) {
        localVarQueryParameter['title'] = title
      }

      if (description !== undefined) {
        localVarQueryParameter['description'] = description
      }

      if (link !== undefined) {
        localVarQueryParameter['link'] = link
      }

      if (room !== undefined) {
        localVarQueryParameter['room'] = room
      }

      if (format !== undefined) {
        localVarQueryParameter['format'] = format
      }

      if (sendNotification !== undefined) {
        localVarQueryParameter['send_notification'] = sendNotification
      }

      localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null
      const headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions
      }
    },
    /**
         * Получение встреч пользователя.  Args:     params (RequestGetMeeting): Параметры для получения встреч.     user (User): Текущий аутентифицированный пользователь.  Returns:     List[Meeting]: Список встреч пользователя.  Raises:     HTTPException: Если встречи не найдены.
         * @summary Get Meetings User
         * @param {number} [offset]
         * @param {number} [limit]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
    getMeetingsUserMeetingGetMeetingsGet(offset?: number, limit?: number, options: any = {}): RequestArgs {
      const localVarPath = '/meeting/get_meetings'
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication OAuth2PasswordBearer required
      // oauth required
      if (configuration && configuration.accessToken) {
        const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
          ? configuration.accessToken('OAuth2PasswordBearer', [])
          : configuration.accessToken
        localVarHeaderParameter['Authorization'] = 'Bearer ' + localVarAccessTokenValue
      }

      if (offset !== undefined) {
        localVarQueryParameter['offset'] = offset
      }

      if (limit !== undefined) {
        localVarQueryParameter['limit'] = limit
      }

      localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null
      const headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions
      }
    },
    /**
         * Обновление информации о встрече.  Args:     params (RequestUpdateMeeting): Параметры для обновления встречи.     user (User): Текущий аутентифицированный пользователь.  Returns:     Meeting: Обновленная встреча.  Raises:     HTTPException: Если встреча не найдена или доступ запрещен.
         * @summary Update Meeting
         * @param {string} id
         * @param {string} [startTime]
         * @param {string} [endTime]
         * @param {string} [title]
         * @param {string} [description]
         * @param {string} [link]
         * @param {string} [room]
         * @param {Format} [format]
         * @param {any} [uNKNOWNBASETYPE]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
    updateMeetingMeetingUpdatePatch(id: string, startTime?: string, endTime?: string, title?: string, description?: string, link?: string, room?: string, format?: Format, uNKNOWNBASETYPE?: any, options: any = {}): RequestArgs {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError('id', 'Required parameter id was null or undefined when calling updateMeetingMeetingUpdatePatch.')
      }
      const localVarPath = '/meeting/update'
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication OAuth2PasswordBearer required
      // oauth required
      if (configuration && configuration.accessToken) {
        const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
          ? configuration.accessToken('OAuth2PasswordBearer', [])
          : configuration.accessToken
        localVarHeaderParameter['Authorization'] = 'Bearer ' + localVarAccessTokenValue
      }

      if (id !== undefined) {
        localVarQueryParameter['id'] = id
      }

      if (startTime !== undefined) {
        localVarQueryParameter['start_time'] = startTime
      }

      if (endTime !== undefined) {
        localVarQueryParameter['end_time'] = endTime
      }

      if (title !== undefined) {
        localVarQueryParameter['title'] = title
      }

      if (description !== undefined) {
        localVarQueryParameter['description'] = description
      }

      if (link !== undefined) {
        localVarQueryParameter['link'] = link
      }

      if (room !== undefined) {
        localVarQueryParameter['room'] = room
      }

      if (format !== undefined) {
        localVarQueryParameter['format'] = format
      }

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null
      const headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      const needsSerialization = (typeof uNKNOWNBASETYPE !== 'string') || localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.data = needsSerialization ? JSON.stringify(uNKNOWNBASETYPE !== undefined ? uNKNOWNBASETYPE : {}) : (uNKNOWNBASETYPE || '')

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions
      }
    }
  }
}

/**
 * MeetingApi - functional programming interface
 * @export
 */
export const MeetingApiFp = function(configuration?: Configuration) {
  return {
    /**
         * Отмена встречи.  Args:     params (RequestCancelMeeting): Параметры для отмены встречи.     user (User): Текущий аутентифицированный пользователь.  Raises:     HTTPException: Если встреча не найдена или доступ запрещен.
         * @summary Cancel Meeting
         * @param {string} id
         * @param {boolean} [sendNotification]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
    cancelMeetingMeetingCancelMeetingPatch(id: string, sendNotification?: boolean, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object> {
      const localVarAxiosArgs = MeetingApiAxiosParamCreator(configuration).cancelMeetingMeetingCancelMeetingPatch(id, sendNotification, options)
      return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
        const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
         * Создание новой встречи.  Args:     params (RequestCreateMeeting): Параметры для создания встречи.     user (User): Текущий аутентифицированный пользователь.  Returns:     ResponseCreateMeeting: Ответ с идентификатором созданной встречи.
         * @summary Create Meeting
         * @param {string} startTime
         * @param {string} endTime
         * @param {Format} format
         * @param {string} [participants]
         * @param {string} [title]
         * @param {string} [description]
         * @param {string} [link]
         * @param {string} [room]
         * @param {boolean} [sendNotification]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
    createMeetingMeetingCreateMeetingPost(startTime: string, endTime: string, format: Format, participants?: string, title?: string, description?: string, link?: string, room?: string, sendNotification?: boolean, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseCreateMeeting> {
      const localVarAxiosArgs = MeetingApiAxiosParamCreator(configuration).createMeetingMeetingCreateMeetingPost(startTime, endTime, format, participants, title, description, link, room, sendNotification, options)
      return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
        const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
         * Получение встреч пользователя.  Args:     params (RequestGetMeeting): Параметры для получения встреч.     user (User): Текущий аутентифицированный пользователь.  Returns:     List[Meeting]: Список встреч пользователя.  Raises:     HTTPException: Если встречи не найдены.
         * @summary Get Meetings User
         * @param {number} [offset]
         * @param {number} [limit]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
    getMeetingsUserMeetingGetMeetingsGet(offset?: number, limit?: number, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Meeting>> {
      const localVarAxiosArgs = MeetingApiAxiosParamCreator(configuration).getMeetingsUserMeetingGetMeetingsGet(offset, limit, options)
      return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
        const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
         * Обновление информации о встрече.  Args:     params (RequestUpdateMeeting): Параметры для обновления встречи.     user (User): Текущий аутентифицированный пользователь.  Returns:     Meeting: Обновленная встреча.  Raises:     HTTPException: Если встреча не найдена или доступ запрещен.
         * @summary Update Meeting
         * @param {string} id
         * @param {string} [startTime]
         * @param {string} [endTime]
         * @param {string} [title]
         * @param {string} [description]
         * @param {string} [link]
         * @param {string} [room]
         * @param {Format} [format]
         * @param {any} [uNKNOWNBASETYPE]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
    updateMeetingMeetingUpdatePatch(id: string, startTime?: string, endTime?: string, title?: string, description?: string, link?: string, room?: string, format?: Format, uNKNOWNBASETYPE?: any, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Meeting> {
      const localVarAxiosArgs = MeetingApiAxiosParamCreator(configuration).updateMeetingMeetingUpdatePatch(id, startTime, endTime, title, description, link, room, format, uNKNOWNBASETYPE, options)
      return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
        const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url }
        return axios.request(axiosRequestArgs)
      }
    }
  }
}

/**
 * MeetingApi - factory interface
 * @export
 */
export const MeetingApiFactory = function(configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
  return {
    /**
         * Отмена встречи.  Args:     params (RequestCancelMeeting): Параметры для отмены встречи.     user (User): Текущий аутентифицированный пользователь.  Raises:     HTTPException: Если встреча не найдена или доступ запрещен.
         * @summary Cancel Meeting
         * @param {string} id
         * @param {boolean} [sendNotification]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
    cancelMeetingMeetingCancelMeetingPatch(id: string, sendNotification?: boolean, options?: any): AxiosPromise<object> {
      return MeetingApiFp(configuration).cancelMeetingMeetingCancelMeetingPatch(id, sendNotification, options)(axios, basePath)
    },
    /**
         * Создание новой встречи.  Args:     params (RequestCreateMeeting): Параметры для создания встречи.     user (User): Текущий аутентифицированный пользователь.  Returns:     ResponseCreateMeeting: Ответ с идентификатором созданной встречи.
         * @summary Create Meeting
         * @param {string} startTime
         * @param {string} endTime
         * @param {Format} format
         * @param {string} [participants]
         * @param {string} [title]
         * @param {string} [description]
         * @param {string} [link]
         * @param {string} [room]
         * @param {boolean} [sendNotification]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
    createMeetingMeetingCreateMeetingPost(startTime: string, endTime: string, format: Format, participants?: string, title?: string, description?: string, link?: string, room?: string, sendNotification?: boolean, options?: any): AxiosPromise<ResponseCreateMeeting> {
      return MeetingApiFp(configuration).createMeetingMeetingCreateMeetingPost(startTime, endTime, format, participants, title, description, link, room, sendNotification, options)(axios, basePath)
    },
    /**
         * Получение встреч пользователя.  Args:     params (RequestGetMeeting): Параметры для получения встреч.     user (User): Текущий аутентифицированный пользователь.  Returns:     List[Meeting]: Список встреч пользователя.  Raises:     HTTPException: Если встречи не найдены.
         * @summary Get Meetings User
         * @param {number} [offset]
         * @param {number} [limit]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
    getMeetingsUserMeetingGetMeetingsGet(offset?: number, limit?: number, options?: any): AxiosPromise<Array<Meeting>> {
      return MeetingApiFp(configuration).getMeetingsUserMeetingGetMeetingsGet(offset, limit, options)(axios, basePath)
    },
    /**
         * Обновление информации о встрече.  Args:     params (RequestUpdateMeeting): Параметры для обновления встречи.     user (User): Текущий аутентифицированный пользователь.  Returns:     Meeting: Обновленная встреча.  Raises:     HTTPException: Если встреча не найдена или доступ запрещен.
         * @summary Update Meeting
         * @param {string} id
         * @param {string} [startTime]
         * @param {string} [endTime]
         * @param {string} [title]
         * @param {string} [description]
         * @param {string} [link]
         * @param {string} [room]
         * @param {Format} [format]
         * @param {any} [uNKNOWNBASETYPE]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
    updateMeetingMeetingUpdatePatch(id: string, startTime?: string, endTime?: string, title?: string, description?: string, link?: string, room?: string, format?: Format, uNKNOWNBASETYPE?: any, options?: any): AxiosPromise<Meeting> {
      return MeetingApiFp(configuration).updateMeetingMeetingUpdatePatch(id, startTime, endTime, title, description, link, room, format, uNKNOWNBASETYPE, options)(axios, basePath)
    }
  }
}

/**
 * MeetingApi - object-oriented interface
 * @export
 * @class MeetingApi
 * @extends {BaseAPI}
 */
export class MeetingApi extends BaseAPI {
  /**
     * Отмена встречи.  Args:     params (RequestCancelMeeting): Параметры для отмены встречи.     user (User): Текущий аутентифицированный пользователь.  Raises:     HTTPException: Если встреча не найдена или доступ запрещен.
     * @summary Cancel Meeting
     * @param {string} id
     * @param {boolean} [sendNotification]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MeetingApi
     */
  public cancelMeetingMeetingCancelMeetingPatch(id: string, sendNotification?: boolean, options?: any) {
    return MeetingApiFp(this.configuration).cancelMeetingMeetingCancelMeetingPatch(id, sendNotification, options)(this.axios, this.basePath)
  }

  /**
     * Создание новой встречи.  Args:     params (RequestCreateMeeting): Параметры для создания встречи.     user (User): Текущий аутентифицированный пользователь.  Returns:     ResponseCreateMeeting: Ответ с идентификатором созданной встречи.
     * @summary Create Meeting
     * @param {string} startTime
     * @param {string} endTime
     * @param {Format} format
     * @param {string} [participants]
     * @param {string} [title]
     * @param {string} [description]
     * @param {string} [link]
     * @param {string} [room]
     * @param {boolean} [sendNotification]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MeetingApi
     */
  public createMeetingMeetingCreateMeetingPost(startTime: string, endTime: string, format: Format, participants?: string, title?: string, description?: string, link?: string, room?: string, sendNotification?: boolean, options?: any) {
    return MeetingApiFp(this.configuration).createMeetingMeetingCreateMeetingPost(startTime, endTime, format, participants, title, description, link, room, sendNotification, options)(this.axios, this.basePath)
  }

  /**
     * Получение встреч пользователя.  Args:     params (RequestGetMeeting): Параметры для получения встреч.     user (User): Текущий аутентифицированный пользователь.  Returns:     List[Meeting]: Список встреч пользователя.  Raises:     HTTPException: Если встречи не найдены.
     * @summary Get Meetings User
     * @param {number} [offset]
     * @param {number} [limit]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MeetingApi
     */
  public getMeetingsUserMeetingGetMeetingsGet(offset?: number, limit?: number, options?: any) {
    return MeetingApiFp(this.configuration).getMeetingsUserMeetingGetMeetingsGet(offset, limit, options)(this.axios, this.basePath)
  }

  /**
     * Обновление информации о встрече.  Args:     params (RequestUpdateMeeting): Параметры для обновления встречи.     user (User): Текущий аутентифицированный пользователь.  Returns:     Meeting: Обновленная встреча.  Raises:     HTTPException: Если встреча не найдена или доступ запрещен.
     * @summary Update Meeting
     * @param {string} id
     * @param {string} [startTime]
     * @param {string} [endTime]
     * @param {string} [title]
     * @param {string} [description]
     * @param {string} [link]
     * @param {string} [room]
     * @param {Format} [format]
     * @param {any} [uNKNOWNBASETYPE]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MeetingApi
     */
  public updateMeetingMeetingUpdatePatch(id: string, startTime?: string, endTime?: string, title?: string, description?: string, link?: string, room?: string, format?: Format, uNKNOWNBASETYPE?: any, options?: any) {
    return MeetingApiFp(this.configuration).updateMeetingMeetingUpdatePatch(id, startTime, endTime, title, description, link, room, format, uNKNOWNBASETYPE, options)(this.axios, this.basePath)
  }
}

/**
 * MessengerApi - axios parameter creator
 * @export
 */
export const MessengerApiAxiosParamCreator = function(configuration?: Configuration) {
  return {
    /**
         * Создание новой беседы.  Args:     request (CreateConversationRequest): Параметры для создания беседы.     user (User): Текущий аутентифицированный пользователь.  Returns:     CreateConversationResponse: Ответ с идентификатором созданной беседы.
         * @summary Create New Conversation
         * @param {CreateConversationRequest} createConversationRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
    createNewConversationMessengerCreateConversationPost(createConversationRequest: CreateConversationRequest, options: any = {}): RequestArgs {
      // verify required parameter 'createConversationRequest' is not null or undefined
      if (createConversationRequest === null || createConversationRequest === undefined) {
        throw new RequiredError('createConversationRequest', 'Required parameter createConversationRequest was null or undefined when calling createNewConversationMessengerCreateConversationPost.')
      }
      const localVarPath = '/messenger/create_conversation'
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication OAuth2PasswordBearer required
      // oauth required
      if (configuration && configuration.accessToken) {
        const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
          ? configuration.accessToken('OAuth2PasswordBearer', [])
          : configuration.accessToken
        localVarHeaderParameter['Authorization'] = 'Bearer ' + localVarAccessTokenValue
      }

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null
      const headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      const needsSerialization = (typeof createConversationRequest !== 'string') || localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.data = needsSerialization ? JSON.stringify(createConversationRequest !== undefined ? createConversationRequest : {}) : (createConversationRequest || '')

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions
      }
    },
    /**
         * Получение сообщений чата.  Args:     params (GetChatMessageRequest): Параметры для получения сообщений.     user (User): Текущий аутентифицированный пользователь.  Returns:     GetMessageResponseList: Список сообщений чата.
         * @summary Get Chat Messages Person
         * @param {string} companionId
         * @param {number} [offset]
         * @param {number} [limit]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
    getChatMessagesPersonMessengerGetMessagesPost(companionId: string, offset?: number, limit?: number, options: any = {}): RequestArgs {
      // verify required parameter 'companionId' is not null or undefined
      if (companionId === null || companionId === undefined) {
        throw new RequiredError('companionId', 'Required parameter companionId was null or undefined when calling getChatMessagesPersonMessengerGetMessagesPost.')
      }
      const localVarPath = '/messenger/get_messages'
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication OAuth2PasswordBearer required
      // oauth required
      if (configuration && configuration.accessToken) {
        const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
          ? configuration.accessToken('OAuth2PasswordBearer', [])
          : configuration.accessToken
        localVarHeaderParameter['Authorization'] = 'Bearer ' + localVarAccessTokenValue
      }

      if (companionId !== undefined) {
        localVarQueryParameter['companion_id'] = companionId
      }

      if (offset !== undefined) {
        localVarQueryParameter['offset'] = offset
      }

      if (limit !== undefined) {
        localVarQueryParameter['limit'] = limit
      }

      localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null
      const headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions
      }
    },
    /**
         *
         * @summary Get Chat
         * @param {string} companionId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
    getChatMessengerChatPost(companionId: string, options: any = {}): RequestArgs {
      // verify required parameter 'companionId' is not null or undefined
      if (companionId === null || companionId === undefined) {
        throw new RequiredError('companionId', 'Required parameter companionId was null or undefined when calling getChatMessengerChatPost.')
      }
      const localVarPath = '/messenger/chat'
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication OAuth2PasswordBearer required
      // oauth required
      if (configuration && configuration.accessToken) {
        const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
          ? configuration.accessToken('OAuth2PasswordBearer', [])
          : configuration.accessToken
        localVarHeaderParameter['Authorization'] = 'Bearer ' + localVarAccessTokenValue
      }

      if (companionId !== undefined) {
        localVarQueryParameter['companion_id'] = companionId
      }

      localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null
      const headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions
      }
    },
    /**
         * Получение списка чатов пользователя.  Args:     params (GetChatsRequest): Параметры для получения чатов.     user (User): Текущий аутентифицированный пользователь.  Returns:     GetChatsResponse: Список чатов пользователя.
         * @summary Get Chats
         * @param {number} [limit]
         * @param {number} [offset]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
    getChatsMessengerChatsPost(limit?: number, offset?: number, options: any = {}): RequestArgs {
      const localVarPath = '/messenger/chats'
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication OAuth2PasswordBearer required
      // oauth required
      if (configuration && configuration.accessToken) {
        const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
          ? configuration.accessToken('OAuth2PasswordBearer', [])
          : configuration.accessToken
        localVarHeaderParameter['Authorization'] = 'Bearer ' + localVarAccessTokenValue
      }

      if (limit !== undefined) {
        localVarQueryParameter['limit'] = limit
      }

      if (offset !== undefined) {
        localVarQueryParameter['offset'] = offset
      }

      localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null
      const headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions
      }
    },
    /**
         * Получение участников беседы.  Args:     conversation_id (str): Идентификатор беседы.     user (User): Текущий аутентифицированный пользователь.  Returns:     List[UserWithoutPassword]: Список участников беседы.  Raises:     HTTPException: Если беседа не найдена.
         * @summary Get Conversation Participants
         * @param {string} conversationId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
    getConversationParticipantsMessengerConversationConversationIdParticipantsGet(conversationId: string, options: any = {}): RequestArgs {
      // verify required parameter 'conversationId' is not null or undefined
      if (conversationId === null || conversationId === undefined) {
        throw new RequiredError('conversationId', 'Required parameter conversationId was null or undefined when calling getConversationParticipantsMessengerConversationConversationIdParticipantsGet.')
      }
      const localVarPath = '/messenger/conversation/{conversation_id}/participants'
        .replace(`{${'conversation_id'}}`, encodeURIComponent(String(conversationId)))
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication OAuth2PasswordBearer required
      // oauth required
      if (configuration && configuration.accessToken) {
        const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
          ? configuration.accessToken('OAuth2PasswordBearer', [])
          : configuration.accessToken
        localVarHeaderParameter['Authorization'] = 'Bearer ' + localVarAccessTokenValue
      }

      localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null
      const headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions
      }
    }
  }
}

/**
 * MessengerApi - functional programming interface
 * @export
 */
export const MessengerApiFp = function(configuration?: Configuration) {
  return {
    /**
         * Создание новой беседы.  Args:     request (CreateConversationRequest): Параметры для создания беседы.     user (User): Текущий аутентифицированный пользователь.  Returns:     CreateConversationResponse: Ответ с идентификатором созданной беседы.
         * @summary Create New Conversation
         * @param {CreateConversationRequest} createConversationRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
    createNewConversationMessengerCreateConversationPost(createConversationRequest: CreateConversationRequest, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateConversationResponse> {
      const localVarAxiosArgs = MessengerApiAxiosParamCreator(configuration).createNewConversationMessengerCreateConversationPost(createConversationRequest, options)
      return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
        const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
         * Получение сообщений чата.  Args:     params (GetChatMessageRequest): Параметры для получения сообщений.     user (User): Текущий аутентифицированный пользователь.  Returns:     GetMessageResponseList: Список сообщений чата.
         * @summary Get Chat Messages Person
         * @param {string} companionId
         * @param {number} [offset]
         * @param {number} [limit]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
    getChatMessagesPersonMessengerGetMessagesPost(companionId: string, offset?: number, limit?: number, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetMessageResponseList> {
      const localVarAxiosArgs = MessengerApiAxiosParamCreator(configuration).getChatMessagesPersonMessengerGetMessagesPost(companionId, offset, limit, options)
      return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
        const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
         *
         * @summary Get Chat
         * @param {string} companionId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
    getChatMessengerChatPost(companionId: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ChatUser> {
      const localVarAxiosArgs = MessengerApiAxiosParamCreator(configuration).getChatMessengerChatPost(companionId, options)
      return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
        const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
         * Получение списка чатов пользователя.  Args:     params (GetChatsRequest): Параметры для получения чатов.     user (User): Текущий аутентифицированный пользователь.  Returns:     GetChatsResponse: Список чатов пользователя.
         * @summary Get Chats
         * @param {number} [limit]
         * @param {number} [offset]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
    getChatsMessengerChatsPost(limit?: number, offset?: number, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetChatsResponse> {
      const localVarAxiosArgs = MessengerApiAxiosParamCreator(configuration).getChatsMessengerChatsPost(limit, offset, options)
      return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
        const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
         * Получение участников беседы.  Args:     conversation_id (str): Идентификатор беседы.     user (User): Текущий аутентифицированный пользователь.  Returns:     List[UserWithoutPassword]: Список участников беседы.  Raises:     HTTPException: Если беседа не найдена.
         * @summary Get Conversation Participants
         * @param {string} conversationId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
    getConversationParticipantsMessengerConversationConversationIdParticipantsGet(conversationId: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UserWithoutPassword>> {
      const localVarAxiosArgs = MessengerApiAxiosParamCreator(configuration).getConversationParticipantsMessengerConversationConversationIdParticipantsGet(conversationId, options)
      return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
        const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url }
        return axios.request(axiosRequestArgs)
      }
    }
  }
}

/**
 * MessengerApi - factory interface
 * @export
 */
export const MessengerApiFactory = function(configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
  return {
    /**
         * Создание новой беседы.  Args:     request (CreateConversationRequest): Параметры для создания беседы.     user (User): Текущий аутентифицированный пользователь.  Returns:     CreateConversationResponse: Ответ с идентификатором созданной беседы.
         * @summary Create New Conversation
         * @param {CreateConversationRequest} createConversationRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
    createNewConversationMessengerCreateConversationPost(createConversationRequest: CreateConversationRequest, options?: any): AxiosPromise<CreateConversationResponse> {
      return MessengerApiFp(configuration).createNewConversationMessengerCreateConversationPost(createConversationRequest, options)(axios, basePath)
    },
    /**
         * Получение сообщений чата.  Args:     params (GetChatMessageRequest): Параметры для получения сообщений.     user (User): Текущий аутентифицированный пользователь.  Returns:     GetMessageResponseList: Список сообщений чата.
         * @summary Get Chat Messages Person
         * @param {string} companionId
         * @param {number} [offset]
         * @param {number} [limit]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
    getChatMessagesPersonMessengerGetMessagesPost(companionId: string, offset?: number, limit?: number, options?: any): AxiosPromise<GetMessageResponseList> {
      return MessengerApiFp(configuration).getChatMessagesPersonMessengerGetMessagesPost(companionId, offset, limit, options)(axios, basePath)
    },
    /**
         *
         * @summary Get Chat
         * @param {string} companionId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
    getChatMessengerChatPost(companionId: string, options?: any): AxiosPromise<ChatUser> {
      return MessengerApiFp(configuration).getChatMessengerChatPost(companionId, options)(axios, basePath)
    },
    /**
         * Получение списка чатов пользователя.  Args:     params (GetChatsRequest): Параметры для получения чатов.     user (User): Текущий аутентифицированный пользователь.  Returns:     GetChatsResponse: Список чатов пользователя.
         * @summary Get Chats
         * @param {number} [limit]
         * @param {number} [offset]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
    getChatsMessengerChatsPost(limit?: number, offset?: number, options?: any): AxiosPromise<GetChatsResponse> {
      return MessengerApiFp(configuration).getChatsMessengerChatsPost(limit, offset, options)(axios, basePath)
    },
    /**
         * Получение участников беседы.  Args:     conversation_id (str): Идентификатор беседы.     user (User): Текущий аутентифицированный пользователь.  Returns:     List[UserWithoutPassword]: Список участников беседы.  Raises:     HTTPException: Если беседа не найдена.
         * @summary Get Conversation Participants
         * @param {string} conversationId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
    getConversationParticipantsMessengerConversationConversationIdParticipantsGet(conversationId: string, options?: any): AxiosPromise<Array<UserWithoutPassword>> {
      return MessengerApiFp(configuration).getConversationParticipantsMessengerConversationConversationIdParticipantsGet(conversationId, options)(axios, basePath)
    }
  }
}

/**
 * MessengerApi - object-oriented interface
 * @export
 * @class MessengerApi
 * @extends {BaseAPI}
 */
export class MessengerApi extends BaseAPI {
  /**
     * Создание новой беседы.  Args:     request (CreateConversationRequest): Параметры для создания беседы.     user (User): Текущий аутентифицированный пользователь.  Returns:     CreateConversationResponse: Ответ с идентификатором созданной беседы.
     * @summary Create New Conversation
     * @param {CreateConversationRequest} createConversationRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessengerApi
     */
  public createNewConversationMessengerCreateConversationPost(createConversationRequest: CreateConversationRequest, options?: any) {
    return MessengerApiFp(this.configuration).createNewConversationMessengerCreateConversationPost(createConversationRequest, options)(this.axios, this.basePath)
  }

  /**
     * Получение сообщений чата.  Args:     params (GetChatMessageRequest): Параметры для получения сообщений.     user (User): Текущий аутентифицированный пользователь.  Returns:     GetMessageResponseList: Список сообщений чата.
     * @summary Get Chat Messages Person
     * @param {string} companionId
     * @param {number} [offset]
     * @param {number} [limit]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessengerApi
     */
  public getChatMessagesPersonMessengerGetMessagesPost(companionId: string, offset?: number, limit?: number, options?: any) {
    return MessengerApiFp(this.configuration).getChatMessagesPersonMessengerGetMessagesPost(companionId, offset, limit, options)(this.axios, this.basePath)
  }

  /**
     *
     * @summary Get Chat
     * @param {string} companionId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessengerApi
     */
  public getChatMessengerChatPost(companionId: string, options?: any) {
    return MessengerApiFp(this.configuration).getChatMessengerChatPost(companionId, options)(this.axios, this.basePath)
  }

  /**
     * Получение списка чатов пользователя.  Args:     params (GetChatsRequest): Параметры для получения чатов.     user (User): Текущий аутентифицированный пользователь.  Returns:     GetChatsResponse: Список чатов пользователя.
     * @summary Get Chats
     * @param {number} [limit]
     * @param {number} [offset]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessengerApi
     */
  public getChatsMessengerChatsPost(limit?: number, offset?: number, options?: any) {
    return MessengerApiFp(this.configuration).getChatsMessengerChatsPost(limit, offset, options)(this.axios, this.basePath)
  }

  /**
     * Получение участников беседы.  Args:     conversation_id (str): Идентификатор беседы.     user (User): Текущий аутентифицированный пользователь.  Returns:     List[UserWithoutPassword]: Список участников беседы.  Raises:     HTTPException: Если беседа не найдена.
     * @summary Get Conversation Participants
     * @param {string} conversationId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessengerApi
     */
  public getConversationParticipantsMessengerConversationConversationIdParticipantsGet(conversationId: string, options?: any) {
    return MessengerApiFp(this.configuration).getConversationParticipantsMessengerConversationConversationIdParticipantsGet(conversationId, options)(this.axios, this.basePath)
  }
}

/**
 * RegisterApi - axios parameter creator
 * @export
 */
export const RegisterApiAxiosParamCreator = function(configuration?: Configuration) {
  return {
    /**
         * Подтверждение регистрации пользователя.  Args:     request (Request): Запрос HTTP.     confirmation_code (str): Код подтверждения регистрации.  Raises:     HTTPException: Если код подтверждения недействителен или произошла ошибка сервера.
         * @summary Confirm Registration
         * @param {string} confirmationCode
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
    confirmRegistrationClientConfirmPost(confirmationCode: string, options: any = {}): RequestArgs {
      // verify required parameter 'confirmationCode' is not null or undefined
      if (confirmationCode === null || confirmationCode === undefined) {
        throw new RequiredError('confirmationCode', 'Required parameter confirmationCode was null or undefined when calling confirmRegistrationClientConfirmPost.')
      }
      const localVarPath = '/client/confirm'
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (confirmationCode !== undefined) {
        localVarQueryParameter['confirmation_code'] = confirmationCode
      }

      localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null
      const headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions
      }
    },
    /**
         * Деактивация пользователя.  Args:     user_id (uuid.UUID): Идентификатор пользователя.     user (User): Текущий аутентифицированный пользователь.  Returns:     None
         * @summary Delete User
         * @param {string} userId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
    deleteUserClientDeleteUserPatch(userId: string, options: any = {}): RequestArgs {
      // verify required parameter 'userId' is not null or undefined
      if (userId === null || userId === undefined) {
        throw new RequiredError('userId', 'Required parameter userId was null or undefined when calling deleteUserClientDeleteUserPatch.')
      }
      const localVarPath = '/client/delete_user'
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication OAuth2PasswordBearer required
      // oauth required
      if (configuration && configuration.accessToken) {
        const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
          ? configuration.accessToken('OAuth2PasswordBearer', [])
          : configuration.accessToken
        localVarHeaderParameter['Authorization'] = 'Bearer ' + localVarAccessTokenValue
      }

      if (userId !== undefined) {
        localVarQueryParameter['user_id'] = userId
      }

      localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null
      const headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions
      }
    },
    /**
         * Регистрация нового пользователя.  Args:     response (Response): Ответ HTTP.     user_data (UserRegister): Данные регистрации пользователя.  Returns:     DefaultResponseRegister: Ответ о регистрации пользователя.
         * @summary Register User
         * @param {string} email
         * @param {string} firstname
         * @param {string} lastname
         * @param {string} phone
         * @param {string} invitationCode
         * @param {string} password
         * @param {string} [position]
         * @param {string} [avatar]
         * @param {string} [middlename]
         * @param {string} [img]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
    registerUserClientRegisterPost(email: string, firstname: string, lastname: string, phone: string, invitationCode: string, password: string, position?: string, avatar?: string, middlename?: string, img?: string, options: any = {}): RequestArgs {
      // verify required parameter 'email' is not null or undefined
      if (email === null || email === undefined) {
        throw new RequiredError('email', 'Required parameter email was null or undefined when calling registerUserClientRegisterPost.')
      }
      // verify required parameter 'firstname' is not null or undefined
      if (firstname === null || firstname === undefined) {
        throw new RequiredError('firstname', 'Required parameter firstname was null or undefined when calling registerUserClientRegisterPost.')
      }
      // verify required parameter 'lastname' is not null or undefined
      if (lastname === null || lastname === undefined) {
        throw new RequiredError('lastname', 'Required parameter lastname was null or undefined when calling registerUserClientRegisterPost.')
      }
      // verify required parameter 'phone' is not null or undefined
      if (phone === null || phone === undefined) {
        throw new RequiredError('phone', 'Required parameter phone was null or undefined when calling registerUserClientRegisterPost.')
      }
      // verify required parameter 'invitationCode' is not null or undefined
      if (invitationCode === null || invitationCode === undefined) {
        throw new RequiredError('invitationCode', 'Required parameter invitationCode was null or undefined when calling registerUserClientRegisterPost.')
      }
      // verify required parameter 'password' is not null or undefined
      if (password === null || password === undefined) {
        throw new RequiredError('password', 'Required parameter password was null or undefined when calling registerUserClientRegisterPost.')
      }
      const localVarPath = '/client/register'
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (email !== undefined) {
        localVarQueryParameter['email'] = email
      }

      if (position !== undefined) {
        localVarQueryParameter['position'] = position
      }

      if (avatar !== undefined) {
        localVarQueryParameter['avatar'] = avatar
      }

      if (firstname !== undefined) {
        localVarQueryParameter['firstname'] = firstname
      }

      if (middlename !== undefined) {
        localVarQueryParameter['middlename'] = middlename
      }

      if (lastname !== undefined) {
        localVarQueryParameter['lastname'] = lastname
      }

      if (phone !== undefined) {
        localVarQueryParameter['phone'] = phone
      }

      if (img !== undefined) {
        localVarQueryParameter['img'] = img
      }

      if (invitationCode !== undefined) {
        localVarQueryParameter['invitation_code'] = invitationCode
      }

      if (password !== undefined) {
        localVarQueryParameter['password'] = password
      }

      localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null
      const headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions
      }
    },
    /**
         * Обновление данных пользователя.  Args:     updated_data (RequestUpdateUserData): Обновленные данные пользователя.     user (User): Текущий аутентифицированный пользователь.  Returns:     ResponseUpdateUserData: Ответ с количеством обновленных записей.
         * @summary Update User
         * @param {string} [position]
         * @param {string} [avatar]
         * @param {string} [firstname]
         * @param {string} [middlename]
         * @param {string} [lastname]
         * @param {string} [phone]
         * @param {string} [invitationCode]
         * @param {string} [login]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
    updateUserClientUpdateUserPatch(position?: string, avatar?: string, firstname?: string, middlename?: string, lastname?: string, phone?: string, invitationCode?: string, login?: string, options: any = {}): RequestArgs {
      const localVarPath = '/client/update_user'
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication OAuth2PasswordBearer required
      // oauth required
      if (configuration && configuration.accessToken) {
        const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
          ? configuration.accessToken('OAuth2PasswordBearer', [])
          : configuration.accessToken
        localVarHeaderParameter['Authorization'] = 'Bearer ' + localVarAccessTokenValue
      }

      if (position !== undefined) {
        localVarQueryParameter['position'] = position
      }

      if (avatar !== undefined) {
        localVarQueryParameter['avatar'] = avatar
      }

      if (firstname !== undefined) {
        localVarQueryParameter['firstname'] = firstname
      }

      if (middlename !== undefined) {
        localVarQueryParameter['middlename'] = middlename
      }

      if (lastname !== undefined) {
        localVarQueryParameter['lastname'] = lastname
      }

      if (phone !== undefined) {
        localVarQueryParameter['phone'] = phone
      }

      if (invitationCode !== undefined) {
        localVarQueryParameter['invitation_code'] = invitationCode
      }

      if (login !== undefined) {
        localVarQueryParameter['login'] = login
      }

      localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null
      const headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions
      }
    }
  }
}

/**
 * RegisterApi - functional programming interface
 * @export
 */
export const RegisterApiFp = function(configuration?: Configuration) {
  return {
    /**
         * Подтверждение регистрации пользователя.  Args:     request (Request): Запрос HTTP.     confirmation_code (str): Код подтверждения регистрации.  Raises:     HTTPException: Если код подтверждения недействителен или произошла ошибка сервера.
         * @summary Confirm Registration
         * @param {string} confirmationCode
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
    confirmRegistrationClientConfirmPost(confirmationCode: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object> {
      const localVarAxiosArgs = RegisterApiAxiosParamCreator(configuration).confirmRegistrationClientConfirmPost(confirmationCode, options)
      return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
        const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
         * Деактивация пользователя.  Args:     user_id (uuid.UUID): Идентификатор пользователя.     user (User): Текущий аутентифицированный пользователь.  Returns:     None
         * @summary Delete User
         * @param {string} userId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
    deleteUserClientDeleteUserPatch(userId: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object> {
      const localVarAxiosArgs = RegisterApiAxiosParamCreator(configuration).deleteUserClientDeleteUserPatch(userId, options)
      return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
        const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
         * Регистрация нового пользователя.  Args:     response (Response): Ответ HTTP.     user_data (UserRegister): Данные регистрации пользователя.  Returns:     DefaultResponseRegister: Ответ о регистрации пользователя.
         * @summary Register User
         * @param {string} email
         * @param {string} firstname
         * @param {string} lastname
         * @param {string} phone
         * @param {string} invitationCode
         * @param {string} password
         * @param {string} [position]
         * @param {string} [avatar]
         * @param {string} [middlename]
         * @param {string} [img]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
    registerUserClientRegisterPost(email: string, firstname: string, lastname: string, phone: string, invitationCode: string, password: string, position?: string, avatar?: string, middlename?: string, img?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<DefaultResponseRegister> {
      const localVarAxiosArgs = RegisterApiAxiosParamCreator(configuration).registerUserClientRegisterPost(email, firstname, lastname, phone, invitationCode, password, position, avatar, middlename, img, options)
      return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
        const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
         * Обновление данных пользователя.  Args:     updated_data (RequestUpdateUserData): Обновленные данные пользователя.     user (User): Текущий аутентифицированный пользователь.  Returns:     ResponseUpdateUserData: Ответ с количеством обновленных записей.
         * @summary Update User
         * @param {string} [position]
         * @param {string} [avatar]
         * @param {string} [firstname]
         * @param {string} [middlename]
         * @param {string} [lastname]
         * @param {string} [phone]
         * @param {string} [invitationCode]
         * @param {string} [login]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
    updateUserClientUpdateUserPatch(position?: string, avatar?: string, firstname?: string, middlename?: string, lastname?: string, phone?: string, invitationCode?: string, login?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseUpdateUserData> {
      const localVarAxiosArgs = RegisterApiAxiosParamCreator(configuration).updateUserClientUpdateUserPatch(position, avatar, firstname, middlename, lastname, phone, invitationCode, login, options)
      return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
        const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url }
        return axios.request(axiosRequestArgs)
      }
    }
  }
}

/**
 * RegisterApi - factory interface
 * @export
 */
export const RegisterApiFactory = function(configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
  return {
    /**
         * Подтверждение регистрации пользователя.  Args:     request (Request): Запрос HTTP.     confirmation_code (str): Код подтверждения регистрации.  Raises:     HTTPException: Если код подтверждения недействителен или произошла ошибка сервера.
         * @summary Confirm Registration
         * @param {string} confirmationCode
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
    confirmRegistrationClientConfirmPost(confirmationCode: string, options?: any): AxiosPromise<object> {
      return RegisterApiFp(configuration).confirmRegistrationClientConfirmPost(confirmationCode, options)(axios, basePath)
    },
    /**
         * Деактивация пользователя.  Args:     user_id (uuid.UUID): Идентификатор пользователя.     user (User): Текущий аутентифицированный пользователь.  Returns:     None
         * @summary Delete User
         * @param {string} userId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
    deleteUserClientDeleteUserPatch(userId: string, options?: any): AxiosPromise<object> {
      return RegisterApiFp(configuration).deleteUserClientDeleteUserPatch(userId, options)(axios, basePath)
    },
    /**
         * Регистрация нового пользователя.  Args:     response (Response): Ответ HTTP.     user_data (UserRegister): Данные регистрации пользователя.  Returns:     DefaultResponseRegister: Ответ о регистрации пользователя.
         * @summary Register User
         * @param {string} email
         * @param {string} firstname
         * @param {string} lastname
         * @param {string} phone
         * @param {string} invitationCode
         * @param {string} password
         * @param {string} [position]
         * @param {string} [avatar]
         * @param {string} [middlename]
         * @param {string} [img]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
    registerUserClientRegisterPost(email: string, firstname: string, lastname: string, phone: string, invitationCode: string, password: string, position?: string, avatar?: string, middlename?: string, img?: string, options?: any): AxiosPromise<DefaultResponseRegister> {
      return RegisterApiFp(configuration).registerUserClientRegisterPost(email, firstname, lastname, phone, invitationCode, password, position, avatar, middlename, img, options)(axios, basePath)
    },
    /**
         * Обновление данных пользователя.  Args:     updated_data (RequestUpdateUserData): Обновленные данные пользователя.     user (User): Текущий аутентифицированный пользователь.  Returns:     ResponseUpdateUserData: Ответ с количеством обновленных записей.
         * @summary Update User
         * @param {string} [position]
         * @param {string} [avatar]
         * @param {string} [firstname]
         * @param {string} [middlename]
         * @param {string} [lastname]
         * @param {string} [phone]
         * @param {string} [invitationCode]
         * @param {string} [login]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
    updateUserClientUpdateUserPatch(position?: string, avatar?: string, firstname?: string, middlename?: string, lastname?: string, phone?: string, invitationCode?: string, login?: string, options?: any): AxiosPromise<ResponseUpdateUserData> {
      return RegisterApiFp(configuration).updateUserClientUpdateUserPatch(position, avatar, firstname, middlename, lastname, phone, invitationCode, login, options)(axios, basePath)
    }
  }
}

/**
 * RegisterApi - object-oriented interface
 * @export
 * @class RegisterApi
 * @extends {BaseAPI}
 */
export class RegisterApi extends BaseAPI {
  /**
     * Подтверждение регистрации пользователя.  Args:     request (Request): Запрос HTTP.     confirmation_code (str): Код подтверждения регистрации.  Raises:     HTTPException: Если код подтверждения недействителен или произошла ошибка сервера.
     * @summary Confirm Registration
     * @param {string} confirmationCode
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RegisterApi
     */
  public confirmRegistrationClientConfirmPost(confirmationCode: string, options?: any) {
    return RegisterApiFp(this.configuration).confirmRegistrationClientConfirmPost(confirmationCode, options)(this.axios, this.basePath)
  }

  /**
     * Деактивация пользователя.  Args:     user_id (uuid.UUID): Идентификатор пользователя.     user (User): Текущий аутентифицированный пользователь.  Returns:     None
     * @summary Delete User
     * @param {string} userId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RegisterApi
     */
  public deleteUserClientDeleteUserPatch(userId: string, options?: any) {
    return RegisterApiFp(this.configuration).deleteUserClientDeleteUserPatch(userId, options)(this.axios, this.basePath)
  }

  /**
     * Регистрация нового пользователя.  Args:     response (Response): Ответ HTTP.     user_data (UserRegister): Данные регистрации пользователя.  Returns:     DefaultResponseRegister: Ответ о регистрации пользователя.
     * @summary Register User
     * @param {string} email
     * @param {string} firstname
     * @param {string} lastname
     * @param {string} phone
     * @param {string} invitationCode
     * @param {string} password
     * @param {string} [position]
     * @param {string} [avatar]
     * @param {string} [middlename]
     * @param {string} [img]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RegisterApi
     */
  public registerUserClientRegisterPost(email: string, firstname: string, lastname: string, phone: string, invitationCode: string, password: string, position?: string, avatar?: string, middlename?: string, img?: string, options?: any) {
    return RegisterApiFp(this.configuration).registerUserClientRegisterPost(email, firstname, lastname, phone, invitationCode, password, position, avatar, middlename, img, options)(this.axios, this.basePath)
  }

  /**
     * Обновление данных пользователя.  Args:     updated_data (RequestUpdateUserData): Обновленные данные пользователя.     user (User): Текущий аутентифицированный пользователь.  Returns:     ResponseUpdateUserData: Ответ с количеством обновленных записей.
     * @summary Update User
     * @param {string} [position]
     * @param {string} [avatar]
     * @param {string} [firstname]
     * @param {string} [middlename]
     * @param {string} [lastname]
     * @param {string} [phone]
     * @param {string} [invitationCode]
     * @param {string} [login]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RegisterApi
     */
  public updateUserClientUpdateUserPatch(position?: string, avatar?: string, firstname?: string, middlename?: string, lastname?: string, phone?: string, invitationCode?: string, login?: string, options?: any) {
    return RegisterApiFp(this.configuration).updateUserClientUpdateUserPatch(position, avatar, firstname, middlename, lastname, phone, invitationCode, login, options)(this.axios, this.basePath)
  }
}

/**
 * UserApi - axios parameter creator
 * @export
 */
export const UserApiAxiosParamCreator = function(configuration?: Configuration) {
  return {
    /**
         * Поиск пользователя по идентификатору (email, телефон, логин).  Args:     params (FindUserRequest): Параметры запроса для поиска пользователя.     user (User): Текущий аутентифицированный пользователь.  Returns:     GetUsersResponse: Ответ с найденными пользователями.
         * @summary Find User Id
         * @param {string} identifier
         * @param {TypeID} [type]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
    findUserIdUserFindUserIdGet(identifier: string, type?: TypeID, options: any = {}): RequestArgs {
      // verify required parameter 'identifier' is not null or undefined
      if (identifier === null || identifier === undefined) {
        throw new RequiredError('identifier', 'Required parameter identifier was null or undefined when calling findUserIdUserFindUserIdGet.')
      }
      const localVarPath = '/user/find_user_id'
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication OAuth2PasswordBearer required
      // oauth required
      if (configuration && configuration.accessToken) {
        const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
          ? configuration.accessToken('OAuth2PasswordBearer', [])
          : configuration.accessToken
        localVarHeaderParameter['Authorization'] = 'Bearer ' + localVarAccessTokenValue
      }

      if (identifier !== undefined) {
        localVarQueryParameter['identifier'] = identifier
      }

      if (type !== undefined) {
        localVarQueryParameter['type'] = type
      }

      localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null
      const headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions
      }
    },
    /**
         * Поиск пользователей по идентификатору (email, телефон, логин) или имени/фамилии.  Args:     params (FindUserRequest): Параметры запроса для поиска пользователя.     user (User): Текущий аутентифицированный пользователь.  Returns:     GetUsersResponse: Ответ с найденными пользователями.
         * @summary Find User
         * @param {string} identifier
         * @param {TypeID} [type]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
    findUserUserFindUserGet(identifier: string, type?: TypeID, options: any = {}): RequestArgs {
      // verify required parameter 'identifier' is not null or undefined
      if (identifier === null || identifier === undefined) {
        throw new RequiredError('identifier', 'Required parameter identifier was null or undefined when calling findUserUserFindUserGet.')
      }
      const localVarPath = '/user/find_user'
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication OAuth2PasswordBearer required
      // oauth required
      if (configuration && configuration.accessToken) {
        const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
          ? configuration.accessToken('OAuth2PasswordBearer', [])
          : configuration.accessToken
        localVarHeaderParameter['Authorization'] = 'Bearer ' + localVarAccessTokenValue
      }

      if (identifier !== undefined) {
        localVarQueryParameter['identifier'] = identifier
      }

      if (type !== undefined) {
        localVarQueryParameter['type'] = type
      }

      localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null
      const headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions
      }
    },
    /**
         * Получение списка пользователей с пагинацией.  Args:     params (GetUsersRequest): Параметры запроса для получения пользователей.     user (User): Текущий аутентифицированный пользователь.  Returns:     GetUsersResponse: Ответ с найденными пользователями.  Raises:     HTTPException: Если пользователи не найдены.
         * @summary Get Users
         * @param {number} [limit]
         * @param {number} [offset]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
    getUsersUserGetUsersGet(limit?: number, offset?: number, options: any = {}): RequestArgs {
      const localVarPath = '/user/get_users'
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication OAuth2PasswordBearer required
      // oauth required
      if (configuration && configuration.accessToken) {
        const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
          ? configuration.accessToken('OAuth2PasswordBearer', [])
          : configuration.accessToken
        localVarHeaderParameter['Authorization'] = 'Bearer ' + localVarAccessTokenValue
      }

      if (limit !== undefined) {
        localVarQueryParameter['limit'] = limit
      }

      if (offset !== undefined) {
        localVarQueryParameter['offset'] = offset
      }

      localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null
      const headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions
      }
    }
  }
}

/**
 * UserApi - functional programming interface
 * @export
 */
export const UserApiFp = function(configuration?: Configuration) {
  return {
    /**
         * Поиск пользователя по идентификатору (email, телефон, логин).  Args:     params (FindUserRequest): Параметры запроса для поиска пользователя.     user (User): Текущий аутентифицированный пользователь.  Returns:     GetUsersResponse: Ответ с найденными пользователями.
         * @summary Find User Id
         * @param {string} identifier
         * @param {TypeID} [type]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
    findUserIdUserFindUserIdGet(identifier: string, type?: TypeID, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetUsersResponse> {
      const localVarAxiosArgs = UserApiAxiosParamCreator(configuration).findUserIdUserFindUserIdGet(identifier, type, options)
      return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
        const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
         * Поиск пользователей по идентификатору (email, телефон, логин) или имени/фамилии.  Args:     params (FindUserRequest): Параметры запроса для поиска пользователя.     user (User): Текущий аутентифицированный пользователь.  Returns:     GetUsersResponse: Ответ с найденными пользователями.
         * @summary Find User
         * @param {string} identifier
         * @param {TypeID} [type]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
    findUserUserFindUserGet(identifier: string, type?: TypeID, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetUsersResponse> {
      const localVarAxiosArgs = UserApiAxiosParamCreator(configuration).findUserUserFindUserGet(identifier, type, options)
      return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
        const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
         * Получение списка пользователей с пагинацией.  Args:     params (GetUsersRequest): Параметры запроса для получения пользователей.     user (User): Текущий аутентифицированный пользователь.  Returns:     GetUsersResponse: Ответ с найденными пользователями.  Raises:     HTTPException: Если пользователи не найдены.
         * @summary Get Users
         * @param {number} [limit]
         * @param {number} [offset]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
    getUsersUserGetUsersGet(limit?: number, offset?: number, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetUsersResponse> {
      const localVarAxiosArgs = UserApiAxiosParamCreator(configuration).getUsersUserGetUsersGet(limit, offset, options)
      return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
        const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url }
        return axios.request(axiosRequestArgs)
      }
    }
  }
}

/**
 * UserApi - factory interface
 * @export
 */
export const UserApiFactory = function(configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
  return {
    /**
         * Поиск пользователя по идентификатору (email, телефон, логин).  Args:     params (FindUserRequest): Параметры запроса для поиска пользователя.     user (User): Текущий аутентифицированный пользователь.  Returns:     GetUsersResponse: Ответ с найденными пользователями.
         * @summary Find User Id
         * @param {string} identifier
         * @param {TypeID} [type]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
    findUserIdUserFindUserIdGet(identifier: string, type?: TypeID, options?: any): AxiosPromise<GetUsersResponse> {
      return UserApiFp(configuration).findUserIdUserFindUserIdGet(identifier, type, options)(axios, basePath)
    },
    /**
         * Поиск пользователей по идентификатору (email, телефон, логин) или имени/фамилии.  Args:     params (FindUserRequest): Параметры запроса для поиска пользователя.     user (User): Текущий аутентифицированный пользователь.  Returns:     GetUsersResponse: Ответ с найденными пользователями.
         * @summary Find User
         * @param {string} identifier
         * @param {TypeID} [type]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
    findUserUserFindUserGet(identifier: string, type?: TypeID, options?: any): AxiosPromise<GetUsersResponse> {
      return UserApiFp(configuration).findUserUserFindUserGet(identifier, type, options)(axios, basePath)
    },
    /**
         * Получение списка пользователей с пагинацией.  Args:     params (GetUsersRequest): Параметры запроса для получения пользователей.     user (User): Текущий аутентифицированный пользователь.  Returns:     GetUsersResponse: Ответ с найденными пользователями.  Raises:     HTTPException: Если пользователи не найдены.
         * @summary Get Users
         * @param {number} [limit]
         * @param {number} [offset]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
    getUsersUserGetUsersGet(limit?: number, offset?: number, options?: any): AxiosPromise<GetUsersResponse> {
      return UserApiFp(configuration).getUsersUserGetUsersGet(limit, offset, options)(axios, basePath)
    }
  }
}

/**
 * UserApi - object-oriented interface
 * @export
 * @class UserApi
 * @extends {BaseAPI}
 */
export class UserApi extends BaseAPI {
  /**
     * Поиск пользователя по идентификатору (email, телефон, логин).  Args:     params (FindUserRequest): Параметры запроса для поиска пользователя.     user (User): Текущий аутентифицированный пользователь.  Returns:     GetUsersResponse: Ответ с найденными пользователями.
     * @summary Find User Id
     * @param {string} identifier
     * @param {TypeID} [type]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
  public findUserIdUserFindUserIdGet(identifier: string, type?: TypeID, options?: any) {
    return UserApiFp(this.configuration).findUserIdUserFindUserIdGet(identifier, type, options)(this.axios, this.basePath)
  }

  /**
     * Поиск пользователей по идентификатору (email, телефон, логин) или имени/фамилии.  Args:     params (FindUserRequest): Параметры запроса для поиска пользователя.     user (User): Текущий аутентифицированный пользователь.  Returns:     GetUsersResponse: Ответ с найденными пользователями.
     * @summary Find User
     * @param {string} identifier
     * @param {TypeID} [type]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
  public findUserUserFindUserGet(identifier: string, type?: TypeID, options?: any) {
    return UserApiFp(this.configuration).findUserUserFindUserGet(identifier, type, options)(this.axios, this.basePath)
  }

  /**
     * Получение списка пользователей с пагинацией.  Args:     params (GetUsersRequest): Параметры запроса для получения пользователей.     user (User): Текущий аутентифицированный пользователь.  Returns:     GetUsersResponse: Ответ с найденными пользователями.  Raises:     HTTPException: Если пользователи не найдены.
     * @summary Get Users
     * @param {number} [limit]
     * @param {number} [offset]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
  public getUsersUserGetUsersGet(limit?: number, offset?: number, options?: any) {
    return UserApiFp(this.configuration).getUsersUserGetUsersGet(limit, offset, options)(this.axios, this.basePath)
  }
}

